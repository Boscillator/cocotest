# Infix Functions:
plus = (+)
mod = (%)
base = int

# Basic Functions:
plus1 = plus$(1)
sqrt(x) = x**0.5
square = (x) -> x**2
plus1sq = square..plus1
sqplus1 = plus1..square
plus1sq_ = (x) -> x |> plus1 |> square
sqplus1_ = (x) -> x |> square |> plus1

# Partial Applications:
sum_ = reduce$((+))
add = zipwith$((+))

# Non-Functional Quick Sort:
def qsort1(l):
    '''Non-Functional Quick Sort.'''
    if len(l) == 0:
        return []
    else:
        split = l.pop(0)
        smalls = []
        larges = []
        for x in l:
            if x <= split:
                smalls.append(x)
            else:
                larges.append(x)
        return qsort(smalls) + [split] + qsort(larges)

# Functional Quick Sort:
def qsort2(l):
    """Functional Quick Sort."""
    if len(l) == 0:
        return []
    else:
        head, tail = l[0], l[1:] # Python Pattern-Matching
        return [x for x in tail if x <= head] + [head] + [x for x in tail if x > head]

# Iterator Quick Sort:
def qsort3(l):
    """Iterator Quick Sort."""
    try:
        head, tail = next(l)
        # Since only next is ever called on l, it only has to be an iterator
        return (x for x in tail if x <= head) :: iter([head]) :: (x for x in tail if x > head)
    except StopIteration:
        return iter([])

# Infinite Iterators:
@recursive
def repeat(elem):
    """Repeat Iterator."""
    yield elem
    repeat(elem)
@recursive
def N(n=0):
    """Natural Numbers."""
    yield n
    N(n+1)
