# Imports:
import random

# Random Number Helper:
def rand_list(n):
    '''Generates A Random List Of Length n.'''
    return [random.randrange(10) for x in range(0, n)]

# Infix Functions:
plus = (+)
mod = (%)
base = int

# Basic Functions:
prod = reduce$((*))
zipwith(f, *args) = map((items) -> f(*items), zip(*args))
zipsum = map$(sum)..zip
plus1 = plus$(1)
sqrt(x) = x**0.5
square = (x) -> x**2
plus1sq = square..plus1
sqplus1 = plus1..square
plus1sq_ = (x) -> x |> plus1 |> square
sqplus1_ = (x) -> x |> square |> plus1
clean = methodcaller("strip")

# Partial Applications:
sum_ = reduce$((+))
concatsum = reduce$([+])
add = zipwith$((+))

# Quick-Sorts:
def qsort1(l):
    '''Non-Functional Quick Sort.'''
    if len(l) == 0:
        return []
    else:
        split = l.pop(0)
        smalls = []
        larges = []
        for x in l:
            if x <= split:
                smalls.append(x)
            else:
                larges.append(x)
        return qsort1(smalls) + [split] + qsort1(larges)
def qsort2(l):
    """Functional Quick Sort."""
    if len(l) == 0:
        return []
    else:
        head, tail = l[0], l[1:] # Python Pattern-Matching
        return (qsort2([x for x in tail if x <= head])
                + [head] # The pivot is a list
                + qsort2([x for x in tail if x > head])
                )
def qsort3(l):
    """Iterator Quick Sort."""
    try:
        tail = iter(l)
        # Since only next is ever called on l, it only has to be an iterator
        head = next(tail)
        return (qsort3((x for x in tail if x <= head))
                :: iter((head,)) # The pivot is an iter
                :: qsort3((x for x in tail if x > head))
                )
    except StopIteration:
        return iter(())
def qsort4(l):
    """Match Quick Sort."""
    match [] in l:
        return l
    match [head] + tail in l:
        return (qsort2([x for x in tail if x <= head])
                + [head] # The pivot is a list
                + qsort2([x for x in tail if x > head])
                )
def qsort5(l):
    """Iterator Match Quick Sort."""
    try:
        match [head] :: tail in l:
            return (qsort3((x for x in tail if x <= head))
                :: iter((head,)) # The pivot is an iter
                :: qsort3((x for x in tail if x > head))
                )
    except StopIteration:
        return iter(())

# Infinite Iterators:
def repeat(elem):
    """Repeat Iterator."""
    while True:
        yield elem
def N(n=0):
    """Natural Numbers."""
    while True:
        yield n
        n += 1

# Recursive Functions:
@recursive
def next_mul_of(n, x):
    if x % n == 0:
        return x
    else:
        return next_mul_of(n, x+1)
@recursive
def collatz(n):
    if n == 1:
        return True
    elif n%2 == 0:
        return collatz(n/2)
    else:
        return collatz(3*n+1)

# Data Blocks:
data preop(x, y):
    def add(self):
        return self.x + self.y
data vector(x, y):
    def __abs__(self):
        return (self.x**2 + self.y**2)**.5
    def transform(self, other):
        match vector(x, y) in other:
            return vector(self.x + x, self.y + y)
        else:
            raise TypeError()
data triangle(a, b, c):
    def is_right(self):
        return self.a**2 + self.b**2 == self.c**2

# Match Functions:
def factorial1(value):
    match 0 in value:
        return 1
    match n is int in value if n > 0:
        return n * factorial1(n-1)
def factorial2(value):
    match (0) in value:
        return 1
    else: match (n is int) in value if n > 0:
        return n * factorial2(n-1)
    else:
        return None
    raise TypeError()
def factorial3(value):
    match 0 in value:
        return 1
    match n is int in value if n > 0:
        return n * factorial3(n-1)
    match [] in value:
        return []
    match [head] + tail in value:
        return [factorial3(head)] + factorial3(tail)
def classify(value):
    match _ is tuple in value:
        match () in value:
            return "empty tuple"
        match (_,) in value:
            return "singleton tuple"
        match (x,x) in value:
            return "duplicate pair tuple of "+str(x)
        match (_,_) in value:
            return "pair tuple"
        else:
            return "tuple"
    match _ is list in value:
        match [] in value:
            return "empty list"
        match [_] in value:
            return "singleton list"
        match [x,x] in value:
            return "duplicate pair list of "+str(x)
        match [_,_] in value:
            return "pair list"
        else:
            return "list"
    match _ is dict in value:
        match {} in value:
            return "empty dict"
        else:
            return "dict"
    match _ is (set, frozenset) in value:
        match s{} in value:
            return "empty set"
        match f{} in value:
            return "empty set"
        match {0} in value:
            return "set of 0"
        else:
            return "set"
    raise TypeError()
def dictpoint(value):
    match {"x":x is int, "y":y is int} in value:
        return (x, y)
    raise TypeError()

# Unicode Functions:
square_u = (x) → x ↑ 2
neg_u = (⁻)
neg_square_u = (x) → x ↦ square_u ↦ neg_u
