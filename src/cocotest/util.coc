# Imports:
import random

# Random Number Helper:
def rand_list(n):
    '''Generates A Random List Of Length n.'''
    return [random.randrange(10) for x in range(0, n)]

# Infix Functions:
plus = (+)
mod = (%)
base = int

# Basic Functions:
zipwith(f, *args) = map((*args) -> f(*args), zip(*args))
plus1 = plus$(1)
sqrt(x) = x**0.5
square = (x) -> x**2
plus1sq = square..plus1
sqplus1 = plus1..square
plus1sq_ = (x) -> x |> plus1 |> square
sqplus1_ = (x) -> x |> square |> plus1

# Partial Applications:
sum_ = reduce$((+))
add = zipwith$((+))

# Non-Functional Quick Sort:
def qsort1(l):
    '''Non-Functional Quick Sort.'''
    if len(l) == 0:
        return []
    else:
        split = l.pop(0)
        smalls = []
        larges = []
        for x in l:
            if x <= split:
                smalls.append(x)
            else:
                larges.append(x)
        return qsort1(smalls) + [split] + qsort1(larges)

# Functional Quick Sort:
def qsort2(l):
    """Functional Quick Sort."""
    if len(l) == 0:
        return []
    else:
        head, tail = l[0], l[1:] # Python Pattern-Matching
        return qsort2([x for x in tail if x <= head]) + [head] + qsort2([x for x in tail if x > head])

# Iterator Quick Sort:
def qsort3(l):
    """Iterator Quick Sort."""
    try:
        tail = iter(l)
        # Since only next is ever called on l, it only has to be an iterator
        head = next(tail)
        return qsort3((x for x in tail if x <= head)) :: iter([head]) :: qsort3((x for x in tail if x > head))
    except StopIteration:
        return iter([])

# Infinite Iterators:
def repeat(elem):
    """Repeat Iterator."""
    while True:
        yield elem
def N(n=0):
    """Natural Numbers."""
    while True:
        yield n
        n += 1

# Recursive Functions:
@recursive
def collatz(n):
    if n == 1:
        return True
    elif n%2 == 0:
        return collatz(n/2)
    else:
        return collatz(3*n+1)

# Data Blocks:
data preop(x, y):
    def add(self):
        return self.x + self.y
